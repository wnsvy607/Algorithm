# Bitmask DP를 이용한 OR 조합 경우의 수 계산

**M개의 비트 문자열 중 정확히 K개를 선택**하여 비트 단위 OR 연산을 수행했을 때 나올 수 있는 **서로 다른 결과 비트 배열의 개수**를 메모리제이션을 통해 계산하는 코드입니다.

조합을 이용한 완전 탐색 방식 대신 **비트마스크 DP** 기법을 사용해서 특정 경우에 효율적으로 동작할 수 있습니다.

---

## 주요 기능

* `dp(String[] bitArrays, int K)` 메서드를 통해 다음을 계산:

  1. 길이 N의 비트 문자열 M개 중
  2. 정확히 K개를 골라 OR 연산을 했을 때
  3. 가능한 서로 다른 OR 결과의 개수 반환

---

## 알고리즘 설명

1. **상태 정의**

   * `dp[j][mask]` (boolean): 지금까지 본 비트 배열 중에서 j개를 골라 OR 연산한 결과가 `mask`가 될 수 있는지 여부.
   * `mask`는 0부터 `2^N-1`까지의 정수로, N비트 패턴을 표현.

2. **초기 조건**

   * `dp[0][0] = true` (아무것도 선택하지 않으면 OR 결과는 0)

3. **전이(Transition)**

   * 각 아이템 `b = masks[i]`에 대해,

     ```text
     for j = K down to 1:
       for mask = 0 to 2^N - 1:
         if dp[j-1][mask] == true:
           dp[j][mask | b] = true;
     ```
   * **j를 뒤부터 앞까지 순회**해서 한 원소는 한 번만 사용됨을 보장

4. **결과 계산**

   * 모든 아이템을 처리한 후 `dp[K]` 행에서 `true` 값의 개수를 세어 반환

---

## ⏱️ 시간·공간 복잡도

* **시간:** $O(M \times K \times 2^N)$

  * M: 비트 문자열 개수
  * K: 선택할 문자열 개수
  * N: 각 문자열 길이

* **공간:** $O(K \times 2^N)$

  * DP 테이블 크기

---